"""
Vulnerability Assessment and Scoring Engine
Advanced algorithms for vulnerability prioritization, risk calculation, and remediation planning
"""

from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
import json
import math
from dataclasses import dataclass
from enum import Enum
from sqlalchemy.orm import Session

from models.vulnerability import (
    Vulnerability, VulnerabilitySeverity, VulnerabilityStatus, VulnerabilityType,
    VulnerabilityAssessment, RemediationTask
)


class VulnerabilityScoringMethod(Enum):
    """Vulnerability scoring methodologies"""
    CVSS_STANDARD = "cvss_standard"              # Standard CVSS scoring
    CVSS_ENVIRONMENTAL = "cvss_environmental"    # CVSS with environmental metrics
    BUSINESS_RISK = "business_risk"              # Business risk-based scoring
    THREAT_INTELLIGENCE = "threat_intelligence"  # Threat intelligence enhanced
    COMPOSITE = "composite"                      # Multiple methodologies combined


@dataclass
class VulnerabilityScore:
    """Vulnerability scoring result"""
    vulnerability_id: int
    base_score: float
    temporal_score: float
    environmental_score: float
    business_risk_score: float
    threat_intelligence_score: float
    composite_score: float
    priority_level: str
    remediation_urgency: str
    confidence_level: float
    scoring_method: str
    calculation_details: Dict[str, Any]
    recommendations: List[str]


@dataclass
class BusinessContext:
    """Business context for vulnerability assessment"""
    asset_criticality: Optional[str] = None
    business_unit: Optional[str] = None
    compliance_requirements: List[str] = None
    data_classification: Optional[str] = None
    network_exposure: Optional[str] = None
    user_base_size: Optional[int] = None
    revenue_impact_potential: Optional[float] = None


@dataclass
class ThreatContext:
    """Threat intelligence context"""
    exploit_availability: bool = False
    exploit_maturity: Optional[str] = None
    active_campaigns: List[str] = None
    threat_actor_interest: Optional[str] = None
    geographic_targeting: List[str] = None
    industry_targeting: List[str] = None
    attack_frequency: Optional[float] = None


class VulnerabilityEngine:
    """Comprehensive vulnerability assessment and scoring engine"""
    
    def __init__(self, db: Session):
        self.db = db
        
        # CVSS Base Metrics Configuration
        self.attack_vector_scores = {
            "Network": 0.85,
            "Adjacent": 0.62,
            "Local": 0.55,
            "Physical": 0.2
        }
        
        self.attack_complexity_scores = {
            "Low": 0.77,
            "High": 0.44
        }
        
        self.privileges_required_scores = {
            "None": 0.85,
            "Low": 0.62,
            "High": 0.27
        }
        
        self.user_interaction_scores = {
            "None": 0.85,
            "Required": 0.62
        }
        
        self.scope_scores = {
            "Changed": True,
            "Unchanged": False
        }
        
        # Impact Scores
        self.impact_scores = {
            "High": 0.56,
            "Low": 0.22,
            "None": 0.0
        }
        
        # Temporal Metrics
        self.exploit_code_maturity_scores = {
            "Not Defined": 1.0,
            "Unproven": 0.91,
            "Proof-of-Concept": 0.94,
            "Functional": 0.97,
            "High": 1.0
        }
        
        self.remediation_level_scores = {
            "Not Defined": 1.0,
            "Official Fix": 0.95,
            "Temporary Fix": 0.96,
            "Workaround": 0.97,
            "Unavailable": 1.0
        }
        
        self.report_confidence_scores = {
            "Not Defined": 1.0,
            "Unknown": 0.92,
            "Reasonable": 0.96,
            "Confirmed": 1.0
        }
        
        # Business Risk Factors
        self.business_risk_multipliers = {
            "asset_criticality": {
                "critical": 2.0,
                "high": 1.5,
                "medium": 1.0,
                "low": 0.7
            },
            "network_exposure": {
                "internet_facing": 2.5,
                "dmz": 2.0,
                "internal": 1.0,
                "isolated": 0.5
            },
            "data_classification": {
                "confidential": 2.0,
                "internal": 1.5,
                "public": 1.0
            }
        }
        
        # Threat Intelligence Multipliers
        self.threat_multipliers = {
            "exploit_maturity": {
                "High": 2.0,
                "Functional": 1.8,
                "Proof-of-Concept": 1.4,
                "Unproven": 1.1,
                "Not Available": 1.0
            },
            "active_campaigns": {
                True: 1.8,
                False: 1.0
            },
            "threat_actor_interest": {
                "high": 1.6,
                "medium": 1.3,
                "low": 1.0
            }
        }
        
        # Priority Thresholds
        self.priority_thresholds = {
            "critical": {"min": 9.0, "max": 10.0},
            "high": {"min": 7.0, "max": 8.9},
            "medium": {"min": 4.0, "max": 6.9},
            "low": {"min": 0.1, "max": 3.9}
        }
        
        # Remediation Urgency SLA (days)
        self.remediation_sla = {
            "critical": 1,
            "high": 7,
            "medium": 30,
            "low": 90
        }
    
    def assess_vulnerability(
        self,
        vulnerability: Vulnerability,
        method: VulnerabilityScoringMethod = VulnerabilityScoringMethod.COMPOSITE,
        business_context: Optional[BusinessContext] = None,
        threat_context: Optional[ThreatContext] = None
    ) -> VulnerabilityScore:
        """Perform comprehensive vulnerability assessment"""
        
        if method == VulnerabilityScoringMethod.CVSS_STANDARD:
            return self._cvss_standard_method(vulnerability)
        elif method == VulnerabilityScoringMethod.CVSS_ENVIRONMENTAL:
            return self._cvss_environmental_method(vulnerability, business_context)
        elif method == VulnerabilityScoringMethod.BUSINESS_RISK:
            return self._business_risk_method(vulnerability, business_context)
        elif method == VulnerabilityScoringMethod.THREAT_INTELLIGENCE:
            return self._threat_intelligence_method(vulnerability, threat_context)
        elif method == VulnerabilityScoringMethod.COMPOSITE:
            return self._composite_method(vulnerability, business_context, threat_context)
        else:
            return self._cvss_standard_method(vulnerability)
    
    def _cvss_standard_method(self, vulnerability: Vulnerability) -> VulnerabilityScore:
        """Standard CVSS 3.1 base scoring"""
        
        # Use existing CVSS score if available
        if vulnerability.cvss_score:
            base_score = vulnerability.cvss_score
        else:
            base_score = self._calculate_cvss_base_score(vulnerability)
        
        # Calculate temporal score
        temporal_score = self._calculate_temporal_score(base_score, vulnerability)
        
        # Determine priority
        priority = self._determine_priority(temporal_score)
        urgency = self._determine_remediation_urgency(priority)
        
        # Calculate confidence level
        confidence = self._calculate_confidence_level(vulnerability, None)
        
        recommendations = self._generate_basic_recommendations(vulnerability, priority)
        
        return VulnerabilityScore(
            vulnerability_id=vulnerability.id,
            base_score=base_score,
            temporal_score=temporal_score,
            environmental_score=0.0,
            business_risk_score=0.0,
            threat_intelligence_score=0.0,
            composite_score=temporal_score,
            priority_level=priority,
            remediation_urgency=urgency,
            confidence_level=confidence,
            scoring_method="cvss_standard",
            calculation_details={
                "cvss_vector": vulnerability.cvss_vector,
                "cvss_version": vulnerability.cvss_version,
                "base_metrics": self._extract_base_metrics(vulnerability),
                "temporal_adjustments": self._get_temporal_adjustments(vulnerability)
            },
            recommendations=recommendations
        )
    
    def _cvss_environmental_method(
        self, 
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext]
    ) -> VulnerabilityScore:
        """CVSS scoring with environmental metrics"""
        
        # Start with temporal score
        base_score = vulnerability.cvss_score or self._calculate_cvss_base_score(vulnerability)
        temporal_score = self._calculate_temporal_score(base_score, vulnerability)
        
        # Calculate environmental score
        environmental_score = self._calculate_environmental_score(
            temporal_score, vulnerability, business_context
        )
        
        priority = self._determine_priority(environmental_score)
        urgency = self._determine_remediation_urgency(priority)
        confidence = self._calculate_confidence_level(vulnerability, business_context)
        
        recommendations = self._generate_environmental_recommendations(
            vulnerability, business_context, priority
        )
        
        return VulnerabilityScore(
            vulnerability_id=vulnerability.id,
            base_score=base_score,
            temporal_score=temporal_score,
            environmental_score=environmental_score,
            business_risk_score=0.0,
            threat_intelligence_score=0.0,
            composite_score=environmental_score,
            priority_level=priority,
            remediation_urgency=urgency,
            confidence_level=confidence,
            scoring_method="cvss_environmental",
            calculation_details={
                "environmental_metrics": self._get_environmental_metrics(business_context),
                "asset_criticality": business_context.asset_criticality if business_context else None,
                "network_exposure": business_context.network_exposure if business_context else None
            },
            recommendations=recommendations
        )
    
    def _business_risk_method(
        self,
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext]
    ) -> VulnerabilityScore:
        """Business risk-based vulnerability scoring"""
        
        base_score = vulnerability.cvss_score or self._calculate_cvss_base_score(vulnerability)
        
        # Apply business risk multipliers
        business_multiplier = self._calculate_business_risk_multiplier(
            vulnerability, business_context
        )
        
        business_risk_score = min(10.0, base_score * business_multiplier)
        
        # Consider compliance requirements
        compliance_adjustment = self._calculate_compliance_adjustment(
            vulnerability, business_context
        )
        
        final_score = min(10.0, business_risk_score + compliance_adjustment)
        
        priority = self._determine_priority(final_score)
        urgency = self._determine_remediation_urgency(priority)
        confidence = self._calculate_confidence_level(vulnerability, business_context)
        
        recommendations = self._generate_business_recommendations(
            vulnerability, business_context, priority
        )
        
        return VulnerabilityScore(
            vulnerability_id=vulnerability.id,
            base_score=base_score,
            temporal_score=0.0,
            environmental_score=0.0,
            business_risk_score=final_score,
            threat_intelligence_score=0.0,
            composite_score=final_score,
            priority_level=priority,
            remediation_urgency=urgency,
            confidence_level=confidence,
            scoring_method="business_risk",
            calculation_details={
                "business_multiplier": business_multiplier,
                "compliance_adjustment": compliance_adjustment,
                "revenue_impact": business_context.revenue_impact_potential if business_context else None
            },
            recommendations=recommendations
        )
    
    def _threat_intelligence_method(
        self,
        vulnerability: Vulnerability,
        threat_context: Optional[ThreatContext]
    ) -> VulnerabilityScore:
        """Threat intelligence enhanced scoring"""
        
        base_score = vulnerability.cvss_score or self._calculate_cvss_base_score(vulnerability)
        
        # Apply threat intelligence multipliers
        threat_multiplier = self._calculate_threat_intelligence_multiplier(
            vulnerability, threat_context
        )
        
        threat_score = min(10.0, base_score * threat_multiplier)
        
        # Consider exploit availability and maturity
        exploit_adjustment = self._calculate_exploit_adjustment(vulnerability, threat_context)
        
        final_score = min(10.0, threat_score + exploit_adjustment)
        
        priority = self._determine_priority(final_score)
        urgency = self._determine_remediation_urgency_with_threat_context(
            priority, threat_context
        )
        confidence = self._calculate_confidence_level_with_threat_intel(
            vulnerability, threat_context
        )
        
        recommendations = self._generate_threat_intelligence_recommendations(
            vulnerability, threat_context, priority
        )
        
        return VulnerabilityScore(
            vulnerability_id=vulnerability.id,
            base_score=base_score,
            temporal_score=0.0,
            environmental_score=0.0,
            business_risk_score=0.0,
            threat_intelligence_score=final_score,
            composite_score=final_score,
            priority_level=priority,
            remediation_urgency=urgency,
            confidence_level=confidence,
            scoring_method="threat_intelligence",
            calculation_details={
                "threat_multiplier": threat_multiplier,
                "exploit_adjustment": exploit_adjustment,
                "active_campaigns": threat_context.active_campaigns if threat_context else [],
                "exploit_maturity": threat_context.exploit_maturity if threat_context else None
            },
            recommendations=recommendations
        )
    
    def _composite_method(
        self,
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext],
        threat_context: Optional[ThreatContext]
    ) -> VulnerabilityScore:
        """Composite scoring using multiple methodologies"""
        
        # Calculate individual scores
        cvss_score = self._cvss_standard_method(vulnerability)
        environmental_score = self._cvss_environmental_method(vulnerability, business_context)
        business_score = self._business_risk_method(vulnerability, business_context)
        threat_score = self._threat_intelligence_method(vulnerability, threat_context)
        
        # Weighted combination
        weights = {
            "cvss": 0.3,
            "environmental": 0.25,
            "business": 0.25,
            "threat": 0.2
        }
        
        composite_score = (
            cvss_score.composite_score * weights["cvss"] +
            environmental_score.composite_score * weights["environmental"] +
            business_score.composite_score * weights["business"] +
            threat_score.composite_score * weights["threat"]
        )
        
        # Adjust for critical factors
        if threat_context and threat_context.exploit_availability:
            composite_score = min(10.0, composite_score * 1.2)
        
        if business_context and business_context.asset_criticality == "critical":
            composite_score = min(10.0, composite_score * 1.15)
        
        priority = self._determine_priority(composite_score)
        urgency = self._determine_remediation_urgency_composite(
            priority, business_context, threat_context
        )
        
        # Combine recommendations
        all_recommendations = []
        all_recommendations.extend(cvss_score.recommendations)
        all_recommendations.extend(environmental_score.recommendations)
        all_recommendations.extend(business_score.recommendations)
        all_recommendations.extend(threat_score.recommendations)
        
        # Remove duplicates while preserving order
        unique_recommendations = list(dict.fromkeys(all_recommendations))
        
        return VulnerabilityScore(
            vulnerability_id=vulnerability.id,
            base_score=cvss_score.base_score,
            temporal_score=cvss_score.temporal_score,
            environmental_score=environmental_score.environmental_score,
            business_risk_score=business_score.business_risk_score,
            threat_intelligence_score=threat_score.threat_intelligence_score,
            composite_score=composite_score,
            priority_level=priority,
            remediation_urgency=urgency,
            confidence_level=max(
                cvss_score.confidence_level,
                environmental_score.confidence_level,
                business_score.confidence_level,
                threat_score.confidence_level
            ),
            scoring_method="composite",
            calculation_details={
                "weights": weights,
                "component_scores": {
                    "cvss": cvss_score.composite_score,
                    "environmental": environmental_score.composite_score,
                    "business": business_score.composite_score,
                    "threat": threat_score.composite_score
                },
                "critical_adjustments": {
                    "exploit_available": threat_context.exploit_availability if threat_context else False,
                    "critical_asset": business_context.asset_criticality == "critical" if business_context else False
                }
            },
            recommendations=unique_recommendations[:10]  # Limit to top 10 recommendations
        )
    
    def _calculate_cvss_base_score(self, vulnerability: Vulnerability) -> float:
        """Calculate CVSS 3.1 base score from vulnerability attributes"""
        
        # Get metric values (with defaults)
        attack_vector = vulnerability.attack_vector or "Network"
        attack_complexity = vulnerability.attack_complexity or "Low"
        privileges_required = vulnerability.privileges_required or "None"
        user_interaction = vulnerability.user_interaction or "None"
        
        # For this example, assume unchanged scope and High impact
        scope_changed = False
        confidentiality_impact = "High"
        integrity_impact = "High"
        availability_impact = "High"
        
        # Calculate exploitability
        exploitability = (
            8.22 * 
            self.attack_vector_scores.get(attack_vector, 0.85) *
            self.attack_complexity_scores.get(attack_complexity, 0.77) *
            self.privileges_required_scores.get(privileges_required, 0.85) *
            self.user_interaction_scores.get(user_interaction, 0.85)
        )
        
        # Calculate impact
        impact_base = (
            1 - (
                (1 - self.impact_scores.get(confidentiality_impact, 0.56)) *
                (1 - self.impact_scores.get(integrity_impact, 0.56)) *
                (1 - self.impact_scores.get(availability_impact, 0.56))
            )
        )
        
        if scope_changed:
            impact = 7.52 * (impact_base - 0.029) - 3.25 * pow(impact_base - 0.02, 15)
        else:
            impact = 6.42 * impact_base
        
        # Calculate base score
        if impact <= 0:
            base_score = 0.0
        else:
            if scope_changed:
                base_score = min(1.08 * (impact + exploitability), 10.0)
            else:
                base_score = min(impact + exploitability, 10.0)
        
        return round(base_score, 1)
    
    def _calculate_temporal_score(self, base_score: float, vulnerability: Vulnerability) -> float:
        """Calculate CVSS temporal score"""
        
        # Get temporal metrics from vulnerability data
        exploit_maturity = vulnerability.exploit_maturity or "Not Defined"
        remediation_level = "Unavailable" if not vulnerability.patch_available else "Official Fix"
        report_confidence = "Confirmed"  # Assume confirmed for detected vulnerabilities
        
        temporal_score = base_score * (
            self.exploit_code_maturity_scores.get(exploit_maturity, 1.0) *
            self.remediation_level_scores.get(remediation_level, 1.0) *
            self.report_confidence_scores.get(report_confidence, 1.0)
        )
        
        return round(temporal_score, 1)
    
    def _calculate_environmental_score(
        self,
        temporal_score: float,
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext]
    ) -> float:
        """Calculate CVSS environmental score"""
        
        if not business_context:
            return temporal_score
        
        # Environmental multipliers based on business context
        multiplier = 1.0
        
        if business_context.asset_criticality:
            multiplier *= self.business_risk_multipliers["asset_criticality"].get(
                business_context.asset_criticality, 1.0
            )
        
        if business_context.network_exposure:
            multiplier *= self.business_risk_multipliers["network_exposure"].get(
                business_context.network_exposure, 1.0
            )
        
        environmental_score = min(10.0, temporal_score * multiplier)
        
        return round(environmental_score, 1)
    
    def _calculate_business_risk_multiplier(
        self,
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext]
    ) -> float:
        """Calculate business risk multiplier"""
        
        multiplier = 1.0
        
        if not business_context:
            return multiplier
        
        # Asset criticality multiplier
        if business_context.asset_criticality:
            multiplier *= self.business_risk_multipliers["asset_criticality"].get(
                business_context.asset_criticality, 1.0
            )
        
        # Network exposure multiplier
        if business_context.network_exposure:
            multiplier *= self.business_risk_multipliers["network_exposure"].get(
                business_context.network_exposure, 1.0
            )
        
        # Data classification multiplier
        if business_context.data_classification:
            multiplier *= self.business_risk_multipliers["data_classification"].get(
                business_context.data_classification, 1.0
            )
        
        # User base size impact
        if business_context.user_base_size:
            if business_context.user_base_size > 10000:
                multiplier *= 1.3
            elif business_context.user_base_size > 1000:
                multiplier *= 1.1
        
        return multiplier
    
    def _calculate_compliance_adjustment(
        self,
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext]
    ) -> float:
        """Calculate compliance-based score adjustment"""
        
        adjustment = 0.0
        
        if not business_context or not business_context.compliance_requirements:
            return adjustment
        
        # High-impact compliance frameworks
        critical_frameworks = ["SOX", "HIPAA", "PCI-DSS", "GDPR"]
        
        for framework in business_context.compliance_requirements:
            if framework in critical_frameworks:
                adjustment += 0.5
        
        # Cap adjustment
        return min(2.0, adjustment)
    
    def _calculate_threat_intelligence_multiplier(
        self,
        vulnerability: Vulnerability,
        threat_context: Optional[ThreatContext]
    ) -> float:
        """Calculate threat intelligence-based multiplier"""
        
        multiplier = 1.0
        
        if not threat_context:
            return multiplier
        
        # Exploit maturity multiplier
        if threat_context.exploit_maturity:
            multiplier *= self.threat_multipliers["exploit_maturity"].get(
                threat_context.exploit_maturity, 1.0
            )
        
        # Active campaigns multiplier
        has_active_campaigns = bool(threat_context.active_campaigns)
        multiplier *= self.threat_multipliers["active_campaigns"][has_active_campaigns]
        
        # Threat actor interest multiplier
        if threat_context.threat_actor_interest:
            multiplier *= self.threat_multipliers["threat_actor_interest"].get(
                threat_context.threat_actor_interest, 1.0
            )
        
        return multiplier
    
    def _calculate_exploit_adjustment(
        self,
        vulnerability: Vulnerability,
        threat_context: Optional[ThreatContext]
    ) -> float:
        """Calculate exploit-based score adjustment"""
        
        adjustment = 0.0
        
        if vulnerability.exploit_available:
            adjustment += 1.0
        
        if vulnerability.in_the_wild:
            adjustment += 1.5
        
        if threat_context and threat_context.active_campaigns:
            adjustment += len(threat_context.active_campaigns) * 0.3
        
        return min(2.0, adjustment)
    
    def _determine_priority(self, score: float) -> str:
        """Determine priority level from score"""
        
        for priority, threshold in self.priority_thresholds.items():
            if threshold["min"] <= score <= threshold["max"]:
                return priority
        
        if score >= 9.0:
            return "critical"
        else:
            return "low"
    
    def _determine_remediation_urgency(self, priority: str) -> str:
        """Determine remediation urgency based on priority"""
        
        sla_days = self.remediation_sla.get(priority, 90)
        
        if sla_days == 1:
            return "immediate"
        elif sla_days <= 7:
            return "urgent"
        elif sla_days <= 30:
            return "normal"
        else:
            return "low"
    
    def _determine_remediation_urgency_with_threat_context(
        self,
        priority: str,
        threat_context: Optional[ThreatContext]
    ) -> str:
        """Enhanced urgency determination with threat context"""
        
        base_urgency = self._determine_remediation_urgency(priority)
        
        if not threat_context:
            return base_urgency
        
        # Escalate urgency for active threats
        if threat_context.active_campaigns:
            if base_urgency == "low":
                return "normal"
            elif base_urgency == "normal":
                return "urgent"
            elif base_urgency == "urgent":
                return "immediate"
        
        return base_urgency
    
    def _determine_remediation_urgency_composite(
        self,
        priority: str,
        business_context: Optional[BusinessContext],
        threat_context: Optional[ThreatContext]
    ) -> str:
        """Composite urgency determination"""
        
        base_urgency = self._determine_remediation_urgency(priority)
        
        escalation_factors = 0
        
        # Business escalation factors
        if business_context:
            if business_context.asset_criticality == "critical":
                escalation_factors += 1
            if business_context.network_exposure == "internet_facing":
                escalation_factors += 1
            if business_context.compliance_requirements and len(business_context.compliance_requirements) > 2:
                escalation_factors += 1
        
        # Threat escalation factors
        if threat_context:
            if threat_context.active_campaigns:
                escalation_factors += 2
            if threat_context.exploit_availability:
                escalation_factors += 1
        
        # Escalate based on factors
        if escalation_factors >= 3:
            if base_urgency in ["low", "normal"]:
                return "urgent"
            elif base_urgency == "urgent":
                return "immediate"
        elif escalation_factors >= 2:
            if base_urgency == "low":
                return "normal"
            elif base_urgency == "normal":
                return "urgent"
        
        return base_urgency
    
    def _calculate_confidence_level(
        self,
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext]
    ) -> float:
        """Calculate confidence level in the assessment"""
        
        confidence_factors = []
        
        # Data quality factors
        if vulnerability.cvss_score:
            confidence_factors.append(0.9)
        else:
            confidence_factors.append(0.6)
        
        if vulnerability.cve_id:
            confidence_factors.append(0.9)
        else:
            confidence_factors.append(0.7)
        
        if vulnerability.verified:
            confidence_factors.append(0.9)
        else:
            confidence_factors.append(0.6)
        
        # Freshness of data
        if vulnerability.discovered_date:
            days_old = (datetime.now() - vulnerability.discovered_date).days
            if days_old <= 30:
                confidence_factors.append(0.9)
            elif days_old <= 90:
                confidence_factors.append(0.8)
            else:
                confidence_factors.append(0.7)
        
        # Business context availability
        if business_context:
            confidence_factors.append(0.8)
        else:
            confidence_factors.append(0.6)
        
        return sum(confidence_factors) / len(confidence_factors)
    
    def _calculate_confidence_level_with_threat_intel(
        self,
        vulnerability: Vulnerability,
        threat_context: Optional[ThreatContext]
    ) -> float:
        """Calculate confidence level with threat intelligence"""
        
        base_confidence = self._calculate_confidence_level(vulnerability, None)
        
        if threat_context:
            # Boost confidence if we have threat intelligence
            base_confidence = min(1.0, base_confidence + 0.1)
        
        return base_confidence
    
    def _generate_basic_recommendations(
        self,
        vulnerability: Vulnerability,
        priority: str
    ) -> List[str]:
        """Generate basic remediation recommendations"""
        
        recommendations = []
        
        if vulnerability.patch_available:
            recommendations.append("Apply available security patch immediately")
        
        if vulnerability.workaround_available:
            recommendations.append("Implement available workaround as temporary mitigation")
        
        if priority in ["critical", "high"]:
            recommendations.append("Prioritize this vulnerability for immediate attention")
            recommendations.append("Consider emergency change process for rapid remediation")
        
        if vulnerability.exploit_available:
            recommendations.append("Monitor for exploitation attempts")
            recommendations.append("Implement additional network monitoring")
        
        recommendations.append("Verify remediation through re-scanning")
        
        return recommendations
    
    def _generate_environmental_recommendations(
        self,
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext],
        priority: str
    ) -> List[str]:
        """Generate environment-specific recommendations"""
        
        recommendations = self._generate_basic_recommendations(vulnerability, priority)
        
        if business_context:
            if business_context.network_exposure == "internet_facing":
                recommendations.append("Consider immediate network isolation")
                recommendations.append("Implement additional perimeter controls")
            
            if business_context.asset_criticality == "critical":
                recommendations.append("Coordinate with business stakeholders")
                recommendations.append("Prepare rollback procedures")
            
            if business_context.compliance_requirements:
                recommendations.append("Review compliance impact and reporting requirements")
        
        return recommendations
    
    def _generate_business_recommendations(
        self,
        vulnerability: Vulnerability,
        business_context: Optional[BusinessContext],
        priority: str
    ) -> List[str]:
        """Generate business-focused recommendations"""
        
        recommendations = self._generate_environmental_recommendations(
            vulnerability, business_context, priority
        )
        
        if business_context:
            if business_context.revenue_impact_potential and business_context.revenue_impact_potential > 100000:
                recommendations.append("Assess business continuity impact")
                recommendations.append("Prepare stakeholder communications")
            
            if business_context.user_base_size and business_context.user_base_size > 1000:
                recommendations.append("Plan user communication strategy")
                recommendations.append("Consider phased remediation approach")
        
        return recommendations
    
    def _generate_threat_intelligence_recommendations(
        self,
        vulnerability: Vulnerability,
        threat_context: Optional[ThreatContext],
        priority: str
    ) -> List[str]:
        """Generate threat intelligence-based recommendations"""
        
        recommendations = self._generate_basic_recommendations(vulnerability, priority)
        
        if threat_context:
            if threat_context.active_campaigns:
                recommendations.append("Implement immediate threat hunting procedures")
                recommendations.append("Enhance security monitoring for campaign indicators")
            
            if threat_context.exploit_availability:
                recommendations.append("Deploy additional IDS/IPS signatures")
                recommendations.append("Consider virtual patching solutions")
            
            if threat_context.threat_actor_interest == "high":
                recommendations.append("Coordinate with threat intelligence team")
                recommendations.append("Implement deception technologies")
        
        return recommendations
    
    def _extract_base_metrics(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """Extract CVSS base metrics from vulnerability"""
        
        return {
            "attack_vector": vulnerability.attack_vector,
            "attack_complexity": vulnerability.attack_complexity,
            "privileges_required": vulnerability.privileges_required,
            "user_interaction": vulnerability.user_interaction,
            "cvss_vector": vulnerability.cvss_vector
        }
    
    def _get_temporal_adjustments(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """Get temporal metric adjustments"""
        
        return {
            "exploit_maturity": vulnerability.exploit_maturity,
            "patch_available": vulnerability.patch_available,
            "exploit_available": vulnerability.exploit_available,
            "in_the_wild": vulnerability.in_the_wild
        }
    
    def _get_environmental_metrics(
        self,
        business_context: Optional[BusinessContext]
    ) -> Dict[str, Any]:
        """Get environmental metrics from business context"""
        
        if not business_context:
            return {}
        
        return {
            "asset_criticality": business_context.asset_criticality,
            "network_exposure": business_context.network_exposure,
            "data_classification": business_context.data_classification,
            "compliance_requirements": business_context.compliance_requirements
        }
    
    def calculate_sla_deadline(self, vulnerability: Vulnerability, priority: str) -> datetime:
        """Calculate SLA deadline for vulnerability remediation"""
        
        sla_days = self.remediation_sla.get(priority, 90)
        
        # Business day calculation (excluding weekends)
        deadline = vulnerability.discovered_date
        days_added = 0
        
        while days_added < sla_days:
            deadline += timedelta(days=1)
            if deadline.weekday() < 5:  # Monday = 0, Sunday = 6
                days_added += 1
        
        return deadline
    
    def bulk_assess_vulnerabilities(
        self,
        vulnerability_ids: List[int],
        method: VulnerabilityScoringMethod = VulnerabilityScoringMethod.COMPOSITE
    ) -> Dict[int, VulnerabilityScore]:
        """Perform bulk vulnerability assessment"""
        
        vulnerabilities = self.db.query(Vulnerability).filter(
            Vulnerability.id.in_(vulnerability_ids)
        ).all()
        
        results = {}
        
        for vuln in vulnerabilities:
            try:
                # Use default contexts for bulk assessment
                business_context = self._get_default_business_context(vuln)
                threat_context = self._get_default_threat_context(vuln)
                
                score = self.assess_vulnerability(
                    vuln, method, business_context, threat_context
                )
                results[vuln.id] = score
                
            except Exception as e:
                # Log error and continue
                results[vuln.id] = None
        
        return results
    
    def _get_default_business_context(self, vulnerability: Vulnerability) -> BusinessContext:
        """Get default business context from vulnerability data"""
        
        return BusinessContext(
            asset_criticality="medium",  # Default
            compliance_requirements=vulnerability.compliance_frameworks or [],
            network_exposure="internal"  # Default
        )
    
    def _get_default_threat_context(self, vulnerability: Vulnerability) -> ThreatContext:
        """Get default threat context from vulnerability data"""
        
        return ThreatContext(
            exploit_availability=vulnerability.exploit_available,
            exploit_maturity=vulnerability.exploit_maturity,
            active_campaigns=[]
        )